

#1.3 What is Node.js 

    브라우저 밖에서 js를 사용할 수 있도록 만든 것

#1.4 What is NPM  

    NPM은 Node.js의 패키지 매니저, Node.js와 같이 설치됨

#2.0 Your First NodeJS Project 

    .json 은 파일에 정보를 저장하기 위한 것

    ctrl + ` 단축키를 눌러 terminal을 열고 git init 명령어를 입력한다.
    github에서 새 repository를 만든 후 경로를 복사한뒤 터미널에 git remote and origin '경로' 를 입력한다.
    이제 git과 연결될 것이고, git은 파일의 변화를 감지하는 프로그램을 의미한다.
    이후 npm init을 터미널에 입력한다.
    npm init은 package.json을 생성하며 
    package.json에는 다양한 정보가 들어있고main은 프로젝트의 대표파일을 의미한다.

#2.1 Installing Express

    package.json 파일의 scripts안에 정의한 내용을 실행 시킬 수 있다.
    ex) "scripts": {
            "win": "node index.js"
        },

        package.json이 있는 Terminal에서 npm run win 입력.
        package.json이 없으면 작동 안함

        npm install express 또는 npm i express 로 패키지 설치 가능

        express 설치 시 작동에 필요한 다른 패키지들도 설치 됨
        express폴더 내 package.json의 dependencies에서 확인 가능

#2.2 Understanding Dependencies

    터미널에서 npm i를 입력하면 package.json 안의 dependencies를 읽어서 자동으로 설치해준다
    공유 프로젝트 할때 모든 패키지를 공유하지 않아도 되는 이점이 있다.
    package-lock.json은 패키지를 안전하게 관리해준다. (버전과 패키지 목록)
    npm install 할때는 반드시 package.json을 닫고 실행해야함. -> npm이 package.json 파일을 수정하기 때문

#2.3 The Tower of Babel 

    nodeJS가 이해하지 못하는 최신 js를 쓸때 babel을 사용하면 컴파일을 해줌

    babel 설치 방법
    npm install --save-dev @babel/core

    package.json에 보면 devDependencies 안에 설치된다.

    dependencies는 프로그램을 실행시키기 위한 package
    devDependencies는 개발자를 위한 dependencies

    설치 시--save-dev라는 명령어와 같이 설치하면 devDependencies안에 작성됨

    npm install @babel/preset-env --save-dev
    설치 후 아래 작업 수행

    touch babel.config.json (touch 명령어는 mac과 linux에서 작동됨)

    babel.config.json 파일 내부에 아래와 같이 입력 
    {
    "presets": ["@babel/preset-env"]
    }

#2.4 Nodemon

    다음 명령어로 설치. npm이 이미 설치되어 잇는 패키지 확인
    npm install @babel/core @babel/node --save-dev

    nodemon은 우리가 만든 파일이 수정되어 저장될때마다 재시작해준다

    package.json의 script에 다음과 같이 작성
    "dev": "nodemon --exec babel-node index.js"
    => nodemon으로 execute한다. babel-node로 index.js를.

#3.0 Your First Server 

    code와 로직을 가지고 있는 파일을 src 폴더 안으로 이동.

    import express from "express";
    위와 같이 입력하면 npm이 알아서 node_mudles 폴더에서 express를 찾아준다.

    서버란 24시간 내내 온라인에 연결된 컴퓨터
    request를 listening 하고 있다가 응답을 보낸다.

    port는 컴퓨터의 network 통로로 여러개 존재하며 높은숫자의 port가 보통 비어있다.

    app.listen(4000, handleListening);
    app.listen(4000, () => console.log());
    위와같이 작성하게되면 서버는 port 4000을 listening 하고 있는 것

    브라우저에 localhost:4000 입력해서 서버에 접속 할 수 있다.
    nodemon 서버 종료하려면 컨트롤 + c

#3.1 GET Requests

    Cannot GET / 
    GET은 HTTP Method. HTTP는 서버끼리 소통하는 방식
    / 는 root
    GET / 는 페이지를 달라는 의미

    웹사이트에 접속할때 브라우저는 웹사이트를 request하고 페이지를 가져다주는 것임.

#3.2 GET Requests part Two

    express application 이 만들어진 다음부터 express와 연관된 코드를 작성해야 한다.
    
    request는 사용자가 아닌 브라우저가 보내는 것이다.

#3.3 Responses

    서버 종료 단축어 ctrl + c

    GET eventhandler 함수에는 아래와 같이 request, response 두개의 argument가 실려온다.

    const handleHome = (req, res) => {};

#3.4 Recap 

    request를 받았을때 resond는 필수. 하지않으면 브라우저는 계속 기다림.

#3.5 Middlewares part One

    middle software란 requset와 resonse 사이에 있는 것을 의미한다.

    handler는 middleware이고 controller라고도 한다.

    middleware는 다음 function으로 작업을 넘겨주는 것 

#3.6 Middlewares part Two

    app.use는 global middleware를 만들 수 있게 해주는 함수. 모든 URL에 사용 됨.
    어떤 URL에도 작동하는 middleware로 app.get전에 와야 한다.
    순서가 영향을 주기 때문에 순서를 유의

    middleware는 일반적인 controller와 같지만 argument에 next function이 추가된다는 것만 다르다.
    app.use가 next(); function을 호출하지 않으면 get이 호출되지 않는다

#3.7 Setup Recap 

    모든것은 package.json으로부터 시작하고 특정장소에 뭔가를 입력하면 npm이 그것을 사용할 수 있다.
    scripts에는 dev라는 별명으로 명령어를 쉽게 입력할 수 있도록 한다.
    dependencies에는 프로젝트에 필요한 패키지. devDependencies는 개발에 필요한 패키지 작성
    node_module 폴더가 커지기 때문에 gitigore에 포함시킨다. 
    npm i 를 하면 package 내용을 읽어서 npm이 필요한 패키지를 자동으로 설치함.
    node.js가 최신 코드를 지원하지 않을 수 있기 때문에 nodemon을 사용.
    babel-node를 사용하기 위해서는 babel.config.json 파일 내부에 preset이 작성되어야 함.

#3.8 Servers Recap

    server란 항상 켜져있고 인터넷에 연결되어 있으면서 request를 listening 하고 있는 컴퓨터이다
    사용자는 브라우저를 통해 request를 보낼 수 있다.

    컴퓨터에는 많은 port가 있고 아래 코드처럼 서버는 포트를 통해 들어오는 request를 listening할 수 있다.
        app.listen(PORT, handleListening);
    
    서버는 종료하지 않고 항상 listening하고있다. 

    서버에 request가 들어왔을때 작동할 함수를 연결해야함.
     / 는 홈페이지를 의미하며 /login, /lecture와 같은 통로를 routes라고 부른다  
    웹사이트는 내가 가는것이 아니라 브라우저가 웹사이트를 서버에게 받는것
    
    express에서는 route, handler 두개의 argument를 가진 app.get() 을 사용해 브라우저와 홈페이지를 연결한다.
    ex) app.get("/", handleHome)

#3.9 Controllers Recap

    handler로 부르는 controller들(middleware)에는 req, res를 argument로 가지고 있음.
    res.enn() 또는 res.send("I love middlewares")로 종료하거나 메세지를 보낼 수 있음.
    express가 controller에 첫번째 인수로 req, 두번째로 res를 전달해준다.

    # Server
    서버는 인터넷에 연결되어 있으며 24시간 꺼지지 않는 컴퓨터이다.
    서버는 클라이언트(여기서는 브라우저)에서 보낸 request 를 받고 response 보낸다.

    # Request, Response
    클라이언트와 서버는 개방된 포트를 통해 request 와 response 를 주고받는다.
    서버는 request 를 받으면 반드시 response 를 해주어야 한다. 브라우저 무한 로딩이 될 수 있기 때문이다.
    HTTP request 는 어떤 route(url) 에 대한 HTTP Method 요청이고 서버는 그 요청에 대한 response 를 해주어야한다. 여기서 중요한 것이 또 **controller**이다.

    # controller
    컨트롤러는 전달받은 request를 처리고 response를 전달하기 위한 콜백함수이다.

#3.10 Middleware Recap
    
    # Middleware
    미들웨어는 컨트롤러가 request 처리 작업을 완료하고 response 를 전달하기 전에 request 처리를 도와주는 콜백함수이다.
    미들웨어는 request 오브젝트와, response 오브젝트 말고도 next 파라미터를 갖는다.
    next 파라미터는 다음으로 request 를 처리할 콜백함수를 담고있고 next()를 통해 넘길 수 있다.
    파라미터의 이름은 꼭 req, res, next로 할 필요는 없지만 이렇게 쓰는것이 일반적이다.
    마지막 controller는 next가 필요가 없음.
    app.use(controller1, controller2, ...) 와 같이 사용 할 수 있다.

#3.11 External Middlewares

    # Morgan 
    NodeJS를 위한 HTTP request logger
    npm i morgan
    https://www.npmjs.com/package/morgan

#4.0 What are Routers? 

    Router 

#4.1 Making Our Routers

    홈에서 바로 갈수있는 /join, /login 와 같은 것들을 global router 라고 부름.

    마케팅 측면이나 깔끔함을 위해 nomadcoders.co/wetube 와 같이 설정하기도 한다.
    로직상으로는 nomadcoders.co/courses/wetube

#4.1 Making Our Routers

    1. Instead using app.get([URL], [Handler]) to handle the request, we can create a router and let the router handle GET request.
    2. Create app.use("/", homeRouter) - This way, when a user sends a GET request, the request gets routed to homeRouter.
    3. Then, create a constant variable called homeRouter as below:
    const homeRouter = express.Router()
    4. Create a handler function as below:
    const handleReq = (req, res) => {res.send("Do something")}
    5. To connect the router to the handler use the code below:
    routerOne.get("/", handleReq);
    6. Then, users will get routed from the Express [app] to Router [homeRouter] to Handler function [handleReq] when users a request to get URL "/".

#4.2 Cleaning the Code 

    코드를 일단 작성한다. 그리고 코드를 다시 정리한다. (clean code 책)

    import는 파일마다 해주어야 함.

    모든 파일은 모듈이기 때문에 다른 파일에 import하기 전에는 export를 해줘야함. 아래와 같이 변수를 export 가능
    export default globalRouter;

    server.js에 아래와 같이 import 해주어야 함.
    import userRouter from "./routers/userRouter";

    default로 export한 object는 import해서 쓸 때 다른 이름으로 사용이 가능하다.

#4.3 Exports

    default로 export 할때와는 다르게 함수나 변수를 직접 export할때는 import 할 때 아래와 같이 이름 그대로 {} 안에 써야함
    import { join } from "../controllers/userController";

    js에서는 new, delete와 같은 기본함수들은 이름으로 사용할 수 없다.

#4.4 Router Recap 

    Router를 사용하는 이유는 URL을 정리하기 위함.
    URL이 어떻게 시작하는지에 따라 작성한다.

#4.5 Architecture Recap

    ../ 은 상위폴더, ./ 은 현재위치를 의미
    terminal 명령어 cd 는 change Directory의 줄임말 

#4.6 Planning Routes 

#4.7 URL Parameters part One

    : 기호를 사용히먄 URL안에 변수를 넣을 수 있다.
    parameter 라고 부름. req 안에 담겨져서 온다.
    req.params

#4.8 URL Parameters part Two

    videoRouter.get("/:id", see); 아래에 
    videoRouter.get("/upload", upload);
    이 있으면 /view 로 가지않고 모두 /:id 로 처리됨. 순서 중요함.

    # 정규식
    \w+: 모든 문자, 숫자 선택
    \d+: 모든 숫자 선택

    # 정규표현식 테스트 사이트
    https://www.regexpal.com

#5.0 Returning HTML

      res.send(
        "<!DOCTYPE html><html lang='ko'><head><title>Wetube</title></head><body><h1>Home</h1><footer>&copy;2021 Wetube -  All rights reserved</footer></body></html>"
        );
        
    HTML을 표시하려면 위와같이 너무 길고 수정이 불편하다.
    이 때 쓰는것이 PUG

#5.1 Configuring Pug
    pug는 우리 app의 view engine이 될 것임. 
    View Engine: 뷰엔진은 서버에서 처리한 데이터 결과값을 정적인 페이지(HTML 파일)에 보다 편리하게 출력해주기 위해 사용
    뷰엔진에서 요구하는 형태로 템플릿 파일(문서)을 만들고, 해당 템플릿 문서에 서버에서 처리한 데이터를 전달하면 해당 데이터를 화면에 출력할 수 있다. //
    
    app에 view engine이 pug임을 알려줘야함
    server.js에 아래와 같이 선언
    app.set("view engine", "pug");

    views 폴더를 현재 디렉토리에 생성 후 home.pug 파일 생성

    render("view file name") 으로 렌더링한다 
    ex) export const trending = (req, res) => res.render("home");

    cwd = current working directory
    현재 작업 디렉토리는 node.js를 실행하고 있는 package.json 파일이 있는 디렉토리 이다.
    
#5.2 Partials

    아래와 같이 입력하면 default Directory를 변경할 수 있다.
    app.set("views", process.cwd() + "/src/views");

    파일명에는 공백 ㄴㄴ 모든 문자는 lower case로

    footer &copy; #{new Date().getFullYear()} Wetube
    pug는 js이기 때문에 위와 같이 js코드 사용 가능.
    pug가 js를 실행해서 유저에게 전달하고 이를 렌더링 이라고 한다.

    include는 다른 파일을 첨부할 수 있다. 
    pug의 강력한 기능.
    ex) include partials/footer.pug

#5.3 Extending Templates

    extends base.pug
    위의 코드로 pug 파일을 다른 pug 파일에서 상속 받을 수 있다.

    block content
    block 을 이용하여 base.pug에 content를 위한 공간을 마련해둘 수 있다.

    상속받은 파일에서 아래와 같이 입력하여 block 안에 content를 집어 넣을 수 있다.
    block content  
        h1 Home!

#5.4 Variables to Templates

    pug 파일 내에서 #{variable} 형태로 js 변수를 받을 수 있다.

    res.render("home", { pageTitle: "Home" });
    위와 같이 home.pug 파일을 render 하는 부분에서 인자로 변수를 넘겨주면 해당 pug 파일에서 변수를 받는다.

#5.5 Recap

    pug는 띄어쓰기와 tab으로 구분된다.

    block 은 상속받은 파일에서 채워넣을 수 있는 빈 공간.

    #{variable} 은 js 변수를 받아들일 수 있는 공간. pug를 render하는 node.js 파일에서 같은 이름의 변수를 보내줘야함

#5.6 MVP Styles

    MVP.css는 HTML 태그에 기본 스타일을 심어줌
    link(rel="stylesheet" href="https://unpkg.com/mvp.css")

    beutiful css 대신 기본 임시방편

#5.7 Conditionals 

    conditionals는 if else 같은 조건을 의미하며

    h1 tag에 한개의 variable만 집어넣는 경우에는 아래와 같이 사용가능
    h1=pageTitle 
    h1 #{pageTitle} 과 같다.

    ex) if fakeUser.loggedIn 
            small Hello #{fakeUser.username}

#5.8 Iteration

    # Iteration (: 반복)
    array와 같이 반복이 가능한 것들에 대해서 반복문을 실행
    c#의 foreach와 동작 방식이 동일하다. 하지만 else문을 null 체크로 바로 사용할 수 있다.

    videos array의 내용에 대해 한번씩 수행한다.
    each 문은 통상적으로 each 단수 in 복수 형태로 많이 사용한다.
    ex) each video in videos 
            li=video

    pug는 each문에 변수가 존재하지 않는지 검사한다.
    ex) each video in videos
            li=video
        else 
            li=Sorry nothing found.

#5.9 Mixins

    Mixin은 partial과 동일하지만 데이터를 받을 수 잇다.

    # mixin.pug 폴더에서 다음과 같이 mixin을 선언
    ex) mixin video(info)
            div
                h4=info.title
                ul  
                    li #{info.rating}/5
                    li #{info.comments} comments.
                    li Posted #{info.createAt}
                    li #{info.views} views

    # mixin.pug 파일을 include 해주고 아래와 같이 +name 으로 사용
    +video(item)

#6.0 Array Database part One

    # string과 js variable 연결해서 사용하는 방법
    1. a(href="/videos/" + video.id)=video.title
    2. a(href=`/videos/${video.id}`)=video.title
    
    const { id } = req.params; 는 const id = req.params.id; 와 같다.

#6.1 Array Database part Two

    조건문으로 값 넣기 
    ex) #{video.views === 1 ? "view" : "views"}

    absolute URL : URL의 앞에 / 를 넣으면 root + 경로로 가게됨.
    ex) /videos 페이지에서 /login 쓰면 /logind으로
    relative URL : URL 앞에 /를 안쓰면 현재 url/newURL로 가게됨
    ex) /videos 페이지에서 /edit 쓰면 /videos/edit으로
    
    변수를 넣어서 URL 이동
    ex) a(href=`${video.id}/edit`)--->localhost:4000/videos/1/edit

#6.2 Edit Video part One

    GET은 
    POST 방식은 파일을 보내거나 Database에 있는 값을 바꾸는 뭔가를 보낼때 사용

#6.3 Edit Video part Two


    videoRouter.get("/:id(\\d+)/edit", getEdit);
    videoRouter.post("/:id(\\d+)/edit", postEdit);
    위의 두줄을 아래의 한 줄로 쓸 수 있다. 하나의 url에 get post 둘다 쓸 때 유용함.
    videoRouter.route("/:id(\\d+)/edit").get(getEdit).post(postEdit)

    redirect() 는 브라우저를 특정 url로 이동시킬 수 있음.

#6.4 Recap 

    mongodb(mongoose)를 db로 사용할 예정

#6.5 More Practice part One
#6.6 More Practice part Two

    form(method="POST", action="/videos/upload")
    action을 통해 form을 전달할 URL설정 가능. 현재 URL default이기 때문에 굳이 안써도 됨.

    const { title } = req.body;
    const newVideo = {
        title,
        rating: 0,
        comments: 0,
        createAt: "just now",
        views: 0,
        id: videos.length + 1,
    };
    위와 같이 프로퍼티 이름과 값 대신 title로만 써도 title: title, 과 같음

#6.7 Introduction to MongoDB 

    mongoDB는 document-based. json like
    일반적인 DB는 SQL 기반

    mongoDB 설치 링크
    https://www.mongodb.com/docs/manual/tutorial/install-mongodb-on-os-x/

#6.8 Connecting to Mongo

    mongoose는 node.js와 mongoDB의 다리 역할

    Terminal에서 mongod 입력 -> mongosh 입력

    에러 뜨면
    인텔맥: mongod --config /usr/local/etc/mongod.conf --fork
    M1: mongod --config /opt/homebrew/etc/mongod.conf --fork

    exit 입력해서 종료

    mongosh 입력해서 나오는 url을 연결해주어야 함
    ex) db.js 
        import mongoose from "mongoose";

        mongoose.connect("mongodb://127.0.0.1:27017/wetube");   

    server.js에 db파일 import. 이 파일은 바로 실행됨
    ex) server.js
        import "./db";

#6.9 CRUD Introduction

    CRUD란?
    C = Create
    R = Read
    U = Updatd
    D = Delete

    model을 만드는 이유는 db에게 설명해주기 위함.
    ex) Video에는 title이 있고 string이다. 

#6.10 Video Model 

    mongoose model의 이름은 소문자가 아닌 대문자로 시작한다.
    
    # Schemas
    몽구스의 모든 것은 스키마로 시작합니다.
    각 스키마는 MongoDB 컬렉션에 매핑되고 해당 컬렉션 내 문서의 모양을 정의합니다.
    https://mongoosejs.com/docs/guide.html#schemas

    # Models
    mongoose.model(modelName, schema):
    모델은 스키마 정의에서 컴파일된 멋진 생성자입니다. 모델의 인스턴스를 document라고 합니다. 모델은 기본 MongoDB 데이터베이스에서 문서를 만들고 읽습니다.
    https://mongoosejs.com/docs/guide.html#models
    https://mongoosejs.com/docs/models.html

    db.js 파일은 db를 mongoose와 연결시켜서 video model을 인식시키는 역할을 한다.
    server.js 파일에 import "./db"; 를 함으로써 서버에 연결

#6.11 Our First Query 

    callback 이란 무엇인가 발생하고 난 다음 호출되는 function을 의미함. 
    
#6.12 Our First Query part Two

    M1 맥 ( 에러해결 )
    Error: couldn't connect to server 127.0.0.1:27017, connection attempt failed: SocketException: Error connecting to 127.0.0.1:27017 :: caused by :: Connection refused :
    connect@src/mongo/shell/mongo.js:372:17

    (*****)
    제가 겪은 모든 에러들과 해결과정 종합해서 정리해보았습니다.
    m1이 파일 저장경로가 달라서 빙빙 돌았었네요..
    mongo 사용후 에러 나오시는분들은 꼭 mongod 실행 후 에러코드 확인해보시길 바랍니다.


    1. mongodb가 켜져있는지 확인
    brew services list >> mongodb 실행중인지 확인
    brew services run mongodb-community >> 서버실행
    + stop (종료) , restart(재시작)

    2. background process 설정
    mongod --config /opt/homebrew/etc/mongod.conf --fork

    --config : 설정하다
    /opt/homebrew/etc/mongod.conf : mongodb Configuration file 위치
    --fork: daemon 모드 설정
    참고 : https://docs.mongodb.com/manual/reference/configuration-options/

    3. mongo 오류시 mongod 실행후 error 코드 확인하기 (***)

    3-1. dbpath error 코드 발생시
    mongodb는 dbpath 경로에 directory(파일)이 생성되어 있어야 작동한다.
    mongodb default dbpath 는 /data/db 이다.

    sudo mkdir /data/db

    sudo: 사용자권한 사용
    mkidir: 다이렉토리 생성
    /data/db: mongodb dbpath default 경로

    mongod --dbpath /data/db : mongod dbpath 설정해주기

    dbpath 설정까지 완료했다면 brew services restart mongodb-community

    심화 ( dbpath 다른곳에 설정하기 )
    vi /opt/homebrew/etc/mongod.conf ( mongod.conf 파일 접속 )


    vi CLI 가 먹히지 않을시
    export PATH=%PATH:/bin:/usr/local/bin:/usr/bin
    참고: https://keepdev.tistory.com/67

    CLI로 편집하기
    o( insert mode ) > 수정 후 > esc 연타 > :wq ( 파일 나가기 )

    storage:
    dbpath: ( 원하는 path 입력 )

    혹은 finder 에서 command + shift + g > /opt/homebrew/etc/mongod.conf 검색

    mongod.conf 에서 dbpath 설정을 마쳤다면
    source /opt/homebrew/etc/mongod.cof
    source : 저장 후 실행

    다시 한 번 더 mongod --dbpath (변경된 경로)

    (mongod --dbpath 로 임시로 경로 변경을 할 수 있지만 다시 킬때마다 영구적으로 설정해주려면 mongod.conf 파일에서 dbpath를 바꾸어주어야합니다.)

    3-2 소켓 오류 발생시 (mongod 에서 확인)
    failed to unlink socket file","attr":{"path":"/tmp/mongodb-27017.sock","error":"permission denied"

    /tmp/mongodb-27017.sock 파일 제거해주면 정상적으로 작동합니다.

    sudo rm -rf /tmp/mongodb-27017.sock

    rm : remove file
    -r : 디렉토리제거가능
    -f : 확인없이 제거

    brew services restart mongodb-community

    참고 : https://stackoverflow.com/questions/63562177/mongod-aborts-on-mac

    Documentation:
    https://docs.mongodb.com/manual/tutorial/install-mongodb-on-os-x/

#6.13 Async Await 

    ex) call back 사용 videoContoroller.js
        console.log("start")
        //Video.find({}, (error, videos) => {
            return res.render("home", { pageTitle: "Home", videos });
        });
        console.log("finished")

    promise는 callback의 최신 버전이라고 생각하면 됨. => async await
    js는 기다리는 기능이 없기 때문에 callback을 썼지만
    await 로 수행될때까지 기다리는것을 직관적으로 확인할 수 있다.
    await이 들어있는 function을 async 로 비동기로 처리할 것을 알려줘야만 await을 사용할 수 있다.

    async await 방식은 어디서 무엇이 오는지 명확하기 안하기 떄문에 두가지 옵션 사용
    # 1. try catch 문으로 try 코드 실행 중 오류 발생 시 catch 문으로 이동하고 해당 error를 파라미터로 사용 할 수 있다.
    ex) videoContoroller.js 
        try {
        const videos = await Video.find({});
        console.log(videos);
        return res.render("home", { pageTitle: "Home", videos });
        } catch (error) {
            return res.render("server-error", { error });
        }

#6.14 Returns and Renders   

    res.render 를 두번 하게되면 오류가 발생한다. render한 것은 다시 render할 수 없음
    - redirect(), sendStatus(), end() 등등 포함 (express에서 오류 발생)
    
    return 자체가 필수 요소는 아니지만 res.render 이후에 res 을 사용하면 어짜피 에러가 나기 때문에
    에러가 나기전에 return으로 function을 종료해 주는 것임. 
    -> return 은 실수를 방지하기 위해 function을 마무리 짓는 역할로 사용 하는 것

    callback 형태로 사용시 callback 함수가 상위 function 이후에 실행되기 때문에 return 순서에 헷갈릴 수 있음.
    ex) videoContoroller.js
        export const home = (req, res) => {
        Video.find({}, (error, videos) => {
            return res.render("home", { pageTitle: "Home", videos });
        });
        return res.end();
        };

#6.15 Creating a Video part One 

    form의 input에는 각기 다른 name을 부여해줘야 함.

    split(",") 함수를 이용해 , 를 기준으로 string을 array로 받을 수 있다.

    map 함수를 이용해 단어 앞에 # 추가
    ex) hasgtags: hashtags.split(",").map((word) => `#${word}`),

#6.16 Creating a Video part Two

    mongoose는 string 타입에 number를 넣어도 자동으로 string으로 변환해 준다.

    데이터의 형태를 미리 정의해두고 잘못된 정보를 기록하면 mongoose가 데이터 타입의 유효성 검사를 도와준다.

    save() fuction은 promise를 return 해준다.
    db에 save 하는데 시간이 걸리기 때문임.
    이 말은 save가 실행되기까지 기다려줘야 한다는 뜻이다. 따라서 async await 처리 필요
    ex) videoContoroller.js

        export const postUpload = async (req, res) => {
            const { title, description, hashtags } = req.body;
            const video = new Video({
                title,
                description,
                createdAt: Date.now(),
                hasgtags: hashtags.split(",").map((word) => `#${word}`),
                meta: {
                views: 0,
                rating: 0,
                },
            });
            const dbVideo = await video.save();

        아래 코드와 위 코드의 결과는 같다.

        await video.create({
        title,
        description,
        createdAt: Date.now(),
        hasgtags: hashtags.split(",").map((word) => `#${word}`),
        meta: {
        views: 0,
        rating: 0,
        },
        });

    database는 우리가 데이터를 잘못 입력했을때 오류를 발생시켜줌.