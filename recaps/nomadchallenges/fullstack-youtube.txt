

#1.3 What is Node.js 

    브라우저 밖에서 js를 사용할 수 있도록 만든 것

#1.4 What is NPM  

    NPM은 Node.js의 패키지 매니저, Node.js와 같이 설치됨

#2.0 Your First NodeJS Project 

    .json 은 파일에 정보를 저장하기 위한 것

    ctrl + ` 단축키를 눌러 terminal을 열고 git init 명령어를 입력한다.
    github에서 새 repository를 만든 후 경로를 복사한뒤 터미널에 git remote and origin '경로' 를 입력한다.
    이제 git과 연결될 것이고, git은 파일의 변화를 감지하는 프로그램을 의미한다.
    이후 npm init을 터미널에 입력한다.
    npm init은 package.json을 생성하며 
    package.json에는 다양한 정보가 들어있고main은 프로젝트의 대표파일을 의미한다.

#2.1 Installing Express

    package.json 파일의 scripts안에 정의한 내용을 실행 시킬 수 있다.
    ex) "scripts": {
            "win": "node index.js"
        },

        package.json이 있는 Terminal에서 npm run win 입력.
        package.json이 없으면 작동 안함

        npm install express 또는 npm i express 로 패키지 설치 가능

        express 설치 시 작동에 필요한 다른 패키지들도 설치 됨
        express폴더 내 package.json의 dependencies에서 확인 가능

#2.2 Understanding Dependencies

    터미널에서 npm i를 입력하면 package.json 안의 dependencies를 읽어서 자동으로 설치해준다
    공유 프로젝트 할때 모든 패키지를 공유하지 않아도 되는 이점이 있다.
    package-lock.json은 패키지를 안전하게 관리해준다. (버전과 패키지 목록)
    npm install 할때는 반드시 package.json을 닫고 실행해야함. -> npm이 package.json 파일을 수정하기 때문

#2.3 The Tower of Babel 

    nodeJS가 이해하지 못하는 최신 js를 쓸때 babel을 사용하면 컴파일을 해줌

    babel 설치 방법
    npm install --save-dev @babel/core

    package.json에 보면 devDependencies 안에 설치된다.

    dependencies는 프로그램을 실행시키기 위한 package
    devDependencies는 개발자를 위한 dependencies

    설치 시--save-dev라는 명령어와 같이 설치하면 devDependencies안에 작성됨

    npm install @babel/preset-env --save-dev
    설치 후 아래 작업 수행

    touch babel.config.json (touch 명령어는 mac과 linux에서 작동됨)

    babel.config.json 파일 내부에 아래와 같이 입력 
    {
    "presets": ["@babel/preset-env"]
    }

#2.4 Nodemon

    다음 명령어로 설치. npm이 이미 설치되어 잇는 패키지 확인
    npm install @babel/core @babel/node --save-dev

    nodemon은 우리가 만든 파일이 수정되어 저장될때마다 재시작해준다

    package.json의 script에 다음과 같이 작성
    "dev": "nodemon --exec babel-node index.js"
    => nodemon으로 execute한다. babel-node로 index.js를.

#3.0 Your First Server 

    code와 로직을 가지고 있는 파일을 src 폴더 안으로 이동.

    import express from "express";
    위와 같이 입력하면 npm이 알아서 node_mudles 폴더에서 express를 찾아준다.

    서버란 24시간 내내 온라인에 연결된 컴퓨터
    request를 listening 하고 있다가 응답을 보낸다.

    port는 컴퓨터의 network 통로로 여러개 존재하며 높은숫자의 port가 보통 비어있다.

    app.listen(4000, handleListening);
    app.listen(4000, () => console.log());
    위와같이 작성하게되면 서버는 port 4000을 listening 하고 있는 것

    브라우저에 localhost:4000 입력해서 서버에 접속 할 수 있다.
    nodemon 서버 종료하려면 컨트롤 + c

#3.1 GET Requests

    Cannot GET / 
    GET은 HTTP Method. HTTP는 서버끼리 소통하는 방식
    / 는 root
    GET / 는 페이지를 달라는 의미

    웹사이트에 접속할때 브라우저는 웹사이트를 request하고 페이지를 가져다주는 것임.

#3.2 GET Requests part Two

    express application 이 만들어진 다음부터 express와 연관된 코드를 작성해야 한다.
    
    request는 사용자가 아닌 브라우저가 보내는 것이다.

#3.3 Responses

    서버 종료 단축어 ctrl + c

    GET eventhandler 함수에는 아래와 같이 request, response 두개의 argument가 실려온다.

    const handleHome = (req, res) => {};

#3.4 Recap 

    request를 받았을때 resond는 필수. 하지않으면 브라우저는 계속 기다림.

#3.5 Middlewares part One

    middle software란 requset와 resonse 사이에 있는 것을 의미한다.

    handler는 middleware이고 controller라고도 한다.

    middleware는 다음 function으로 작업을 넘겨주는 것 

#3.6 Middlewares part Two

    app.use는 global middleware를 만들 수 있게 해주는 함수. 모든 URL에 사용 됨.
    어떤 URL에도 작동하는 middleware로 app.get전에 와야 한다.
    순서가 영향을 주기 때문에 순서를 유의

    middleware는 일반적인 controller와 같지만 argument에 next function이 추가된다는 것만 다르다.
    app.use가 next(); function을 호출하지 않으면 get이 호출되지 않는다

#3.7 Setup Recap 

    모든것은 package.json으로부터 시작하고 특정장소에 뭔가를 입력하면 npm이 그것을 사용할 수 있다.
    scripts에는 dev라는 별명으로 명령어를 쉽게 입력할 수 있도록 한다.
    dependencies에는 프로젝트에 필요한 패키지. devDependencies는 개발에 필요한 패키지 작성
    node_module 폴더가 커지기 때문에 gitigore에 포함시킨다. 
    npm i 를 하면 package 내용을 읽어서 npm이 필요한 패키지를 자동으로 설치함.
    node.js가 최신 코드를 지원하지 않을 수 있기 때문에 nodemon을 사용.
    babel-node를 사용하기 위해서는 babel.config.json 파일 내부에 preset이 작성되어야 함.

#3.8 Servers Recap

    server란 항상 켜져있고 인터넷에 연결되어 있으면서 request를 listening 하고 있는 컴퓨터이다
    사용자는 브라우저를 통해 request를 보낼 수 있다.

    컴퓨터에는 많은 port가 있고 아래 코드처럼 서버는 포트를 통해 들어오는 request를 listening할 수 있다.
        app.listen(PORT, handleListening);
    
    서버는 종료하지 않고 항상 listening하고있다. 

    서버에 request가 들어왔을때 작동할 함수를 연결해야함.
     / 는 홈페이지를 의미하며 /login, /lecture와 같은 통로를 routes라고 부른다  
    웹사이트는 내가 가는것이 아니라 브라우저가 웹사이트를 서버에게 받는것
    
    express에서는 route, handler 두개의 argument를 가진 app.get() 을 사용해 브라우저와 홈페이지를 연결한다.
    ex) app.get("/", handleHome)

#3.9 Controllers Recap

    handler로 부르는 controller들(middleware)에는 req, res를 argument로 가지고 있음.
    res.enn() 또는 res.send("I love middlewares")로 종료하거나 메세지를 보낼 수 있음.
    express가 controller에 첫번째 인수로 req, 두번째로 res를 전달해준다.

    # Server
    서버는 인터넷에 연결되어 있으며 24시간 꺼지지 않는 컴퓨터이다.
    서버는 클라이언트(여기서는 브라우저)에서 보낸 request 를 받고 response 보낸다.

    # Request, Response
    클라이언트와 서버는 개방된 포트를 통해 request 와 response 를 주고받는다.
    서버는 request 를 받으면 반드시 response 를 해주어야 한다. 브라우저 무한 로딩이 될 수 있기 때문이다.
    HTTP request 는 어떤 route(url) 에 대한 HTTP Method 요청이고 서버는 그 요청에 대한 response 를 해주어야한다. 여기서 중요한 것이 또 **controller**이다.

    # controller
    컨트롤러는 전달받은 request를 처리고 response를 전달하기 위한 콜백함수이다.

#3.10 Middleware Recap
    
    # Middleware
    미들웨어는 컨트롤러가 request 처리 작업을 완료하고 response 를 전달하기 전에 request 처리를 도와주는 콜백함수이다.
    미들웨어는 request 오브젝트와, response 오브젝트 말고도 next 파라미터를 갖는다.
    next 파라미터는 다음으로 request 를 처리할 콜백함수를 담고있고 next()를 통해 넘길 수 있다.
    파라미터의 이름은 꼭 req, res, next로 할 필요는 없지만 이렇게 쓰는것이 일반적이다.
    마지막 controller는 next가 필요가 없음.
    app.use(controller1, controller2, ...) 와 같이 사용 할 수 있다.

#3.11 External Middlewares

    # Morgan 
    NodeJS를 위한 HTTP request logger
    npm i morgan
    https://www.npmjs.com/package/morgan

#4.0 What are Routers? 

    Router 

#4.1 Making Our Routers

    홈에서 바로 갈수있는 /join, /login 와 같은 것들을 global router 라고 부름.

    마케팅 측면이나 깔끔함을 위해 nomadcoders.co/wetube 와 같이 설정하기도 한다.
    로직상으로는 nomadcoders.co/courses/wetube

#4.1 Making Our Routers (11:05)

    1. Instead using app.get([URL], [Handler]) to handle the request, we can create a router and let the router handle GET request.
    2. Create app.use("/", homeRouter) - This way, when a user sends a GET request, the request gets routed to homeRouter.
    3. Then, create a constant variable called homeRouter as below:
    const homeRouter = express.Router()
    4. Create a handler function as below:
    const handleReq = (req, res) => {res.send("Do something")}
    5. To connect the router to the handler use the code below:
    routerOne.get("/", handleReq);
    6. Then, users will get routed from the Express [app] to Router [homeRouter] to Handler function [handleReq] when users a request to get URL "/".

#4.2 Cleaning the Code 

    코드를 일단 작성한다. 그리고 코드를 다시 정리한다. (clean code 책)

    import는 파일마다 해주어야 함.

    모든 파일은 모듈이기 때문에 다른 파일에 import하기 전에는 export를 해줘야함. 아래와 같이 변수를 export 가능
    export default globalRouter;

    server.js에 아래와 같이 import 해주어야 함.
    import userRouter from "./routers/userRouter";

#4.3 Exports

    default로 export 할때와는 다르게 함수나 변수를 직접 export할때는 import 할 때 아래와 같이 이름 그대로 {} 안에 써야함
    import { join } from "../controllers/userController";

    js에서는 new, delete와 같은 기본함수들은 이름으로 사용할 수 없다.

#4.4 Router Recap 

    Router를 사용하는 이유는 URL을 정리하기 위함.
    URL이 어떻게 시작하는지에 따라 작성한다.

#4.5 Architecture Recap

    ../ 은 상위폴더, ./ 은 현재위치를 의미
    terminal 명령어 cd 는 change Directory의 줄임말 

#4.6 Planning Routes 

#4.7 URL Parameters part One

    : 기호를 사용히먄 URL안에 변수를 넣을 수 있다.
    parameter 라고 부름. req 안에 담겨져서 온다.

#4.8 URL Parameters part Two

    videoRouter.get("/:id", see); 아래에 
    videoRouter.get("/upload", upload);
    이 있으면 /view 로 가지않고 모두 /:id 로 처리됨. 순서 중요함.

    # 정규식
    \w+: 모든 문자, 숫자 선택
    \d+: 모든 숫자 선택

    # 정규표현식 테스트 사이트
    https://www.regexpal.com

#5.0 Returning HTML

      res.send(
        "<!DOCTYPE html><html lang='ko'><head><title>Wetube</title></head><body><h1>Home</h1><footer>&copy;2021 Wetube -  All rights reserved</footer></body></html>"
        );
        
    HTML을 표시하려면 위와같이 너무 길고 수정이 불편하다.
    이 때 쓰는것이 PUG

#5.1 Configuring Pug
    pug는 우리 app의 view engine이 될 것임. 
    View Engine: 뷰엔진은 서버에서 처리한 데이터 결과값을 정적인 페이지(HTML 파일)에 보다 편리하게 출력해주기 위해 사용
    뷰엔진에서 요구하는 형태로 템플릿 파일(문서)을 만들고, 해당 템플릿 문서에 서버에서 처리한 데이터를 전달하면 해당 데이터를 화면에 출력할 수 있다. //
    
    app에 view engine이 pug임을 알려줘야함
    server.js에 아래와 같이 선언
    app.set("view engine", "pug");

    views 폴더를 현재 디렉토리에 생성 후 home.pug 파일 생성

    render("view file name") 으로 렌더링한다 
    ex) export const trending = (req, res) => res.render("home");

    cwd = current working directory
    현재 작업 디렉토리는 node.js를 실행하고 있는 package.json 파일이 있는 디렉토리 이다.
    
#5.2 Partials

    아래와 같이 입력하면 default Directory를 변경할 수 있다.
    app.set("views", process.cwd() + "/src/views");

    파일명에는 공백 ㄴㄴ 모든 문자는 lower case로

    footer &copy; #{new Date().getFullYear()} Wetube
    pug는 js이기 때문에 위와 같이 js코드 사용 가능.
    pug가 js를 실행해서 유저에게 전달하고 이를 렌더링 이라고 한다.

    include는 다른 파일을 첨부할 수 있다. 
    pug의 강력한 기능.
    ex) include partials/footer.pug


